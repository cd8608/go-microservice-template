require 'pathname'
require 'docker'
require 'consul/client'

require_relative 'rake-modules/docker'
require_relative 'rake-modules/consul'
require_relative 'rake-modules/helpers'

REGISTRY_URL = ENV['DOCKER_REGISTRY_URL']
REGISTRY_USER = ENV['DOCKER_REGISTRY_USER']
REGISTRY_PASS = ENV['DOCKER_REGISTRY_PASS']
REGISTRY_EMAIL = ENV['DOCKER_REGISTRY_EMAIL']

DOCKER_NAMESPACE = ENV['DOCKER_NAMESPACE']
DOCKER_IMAGE_NAME = '{{.ServiceName}}'

GOPATH = ENV["GOPATH"]
GOCMD = "/usr/local/go/bin/go"
GONAMESPACE = '{{.Namespace}}'

ROOTFOLDER = Pathname.new(Dir.pwd).parent

task :test  do
	p "Test Application"
	container = get_container

	begin
		# Get go packages
		ret = container.exec(['go','get','-t','-v','./...']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0

		# Test application
		ret = container.exec(['go','test','./...']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :build => [:test] do
	p "Build for Linux"
	container = get_container

	begin
		# Build go server
		ret = container.exec(['go','build','-a','-installsuffix','cgo','-ldflags','\'-s\'','-o','server']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :build_server => [:build] do
	p "Building Docker Image:- #{DOCKER_IMAGE_NAME}"

	FileUtils.cp "#{GOPATH}/src/#{GONAMESPACE}/#{DOCKER_IMAGE_NAME}/server", "./dockerfile/#{DOCKER_IMAGE_NAME}/server"

	Docker.options = {:read_timeout => 6200}
	image = Docker::Image.build_from_dir "./dockerfile/#{DOCKER_IMAGE_NAME}", {:t => DOCKER_IMAGE_NAME}
end

task :run do
	begin
    puts `docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml up -d`
    sleep 2
		setConsulVariables get_docker_ip_address, 9500
		#self.wait_until_server_running ENV['WEB_SERVER_URI']
    sh "docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml logs"
	rescue SystemExit, Interrupt
		sh "docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml stop"
		# remove stopped containers
		sh "echo y | docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml rm"
	end
end

task :docs do
	container = get_container

	begin
		# Get go packages
		ret = container.exec(['go','get','github.com/peterhellberg/hiro']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0

		# Build docs
		ret = container.exec(['go','run','../../peterhellberg/hiro/main.go',"-input=/api-blueprint/#{DOCKER_IMAGE_NAME}.apib", "-output=/api-blueprint/#{DOCKER_IMAGE_NAME}.html"]) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :build_go_build_server do
	p "Building Docker Image:- Dev Server"

	Docker.options = {:read_timeout => 6200}
	image = Docker::Image.build_from_dir './dockerfile/gobuildserver', {:t => 'gobuildserver'}
end

task :e2e do
	feature = ARGV.last
	if feature != "e2e"
		feature = "--tags #{feature}"
	else
		feature = ""
	end

	host = get_docker_ip_address

	puts "Running Tests for #{host}"

	ENV['WEB_SERVER_URI'] = "http://#{host}:8001"
	ENV['MONGO_URI'] = "#{host}:27017"
	ENV['EMAIL_SERVER_URI'] = "http://#{host}:1080"

  puts "Running Tests"
	begin
	  puts `docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml up -d`
    sleep 2
		setConsulVariables host, 9500
		self.wait_until_server_running ENV['WEB_SERVER_URI']

		p 'Running Tests'
		puts `cucumber --color #{feature}`
	ensure
    p 'Stopping Application'
		# remove stop running application
		puts `docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml stop`
		# remove stopped containers
		puts `echo y | docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml rm`
	end
end

task :push do
	p "Push image to registry"

	image =  find_image "#{DOCKER_IMAGE_NAME}:latest"
	image.tag('repo' => "#{DOCKER_NAMESPACE}#{DOCKER_IMAGE_NAME}", 'force' => true) unless image.info["RepoTags"].include? "#{DOCKER_NAMESPACE}#{DOCKER_IMAGE_NAME}:latest"

	sh "docker login -u #{REGISTRY_USER} -p #{REGISTRY_PASS} -e #{REGISTRY_EMAIL} #{REGISTRY_URL}"
	sh "docker push #{DOCKER_NAMESPACE}#{DOCKER_IMAGE_NAME}:latest"
end
